// middleware.js
import { NextResponse } from 'next/server';
import * as jose from 'jose';
const encoder = new TextEncoder();
const SECRET_KEY = encoder.encode('TOKEN_KEY_EXTRADOS_BACK'); // Debe ser seguro y estar configurado en variables de entorno

export async function loginMiddleware(request) {
  const authHeader = request.headers.get('authorization');
  const token = authHeader && authHeader.split(' ')[1];
  // Excluir la ruta /api/login
  if (request.nextUrl.pathname === '/api/login') {
    return NextResponse.next();
  }
  if (!token) {
    //TODO: Redireccion directamente a page/login
    return NextResponse.json({ error: 'No auth token' }, { status: 401 });
  }

  try {
    const { payload } = await jose.jwtVerify(token, SECRET_KEY);
    const response = NextResponse.next();
    response.headers.set('x-user', JSON.stringify(payload.user)); // Si necesitas acceder al usuario en tus handlers de API
    return response;
  } catch (err) {
    try {
      const REFRESH_SECRET_KEY = encoder.encode(
        'TOKEN_KEY_EXTRADOS_BACK_REFRESH'
      ); // Para el refresh token

      //obtiene el refresh token
      let refreshToken = request.cookies.get('refreshToken');

      if (!refreshToken)
        return NextResponse.json({ error: 'No auth token' }, { status: 401 });

      //verifies refresh token and get user data
      const { payload } = await jose.jwtVerify(
        refreshToken.value,
        REFRESH_SECRET_KEY
      );

      //new accessToken generated by user data
      const accessToken = await new jose.SignJWT(payload.user)
        .setProtectedHeader({ alg: 'HS256' })
        .setExpirationTime('2h')
        .sign(SECRET_KEY);

      const response = NextResponse.next();

      //set new accessToken in headers
      response.headers.set('authorization', accessToken);

      return response;
    } catch (error) {
      delete err.payload;
      //TODO: Redireccion directamente a page/login
      return NextResponse.json({ error: err }, { status: 401 });
    }
  }
}
